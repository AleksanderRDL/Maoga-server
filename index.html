<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Backend Roadmap - Gamer Theme</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'VT323', monospace;
            background-color: #0f172a; /* Tailwind slate-900 */
            color: #cbd5e1; /* Tailwind slate-300 */
            overflow-x: hidden; /* Prevent horizontal scroll from animations */
        }
        .font-press-start {
            font-family: 'Press Start 2P', cursive;
        }
        .font-vt323 {
            font-family: 'VT323', monospace;
        }
        .phase {
            background-color: #1e293b; /* Tailwind slate-800 */
            border-radius: 0.375rem; /* Tailwind rounded-md */
            border: 2px solid #ec4899; /* Tailwind pink-500 */
            margin-bottom: 2rem; /* Tailwind mb-8 */
            padding: 1.5rem; /* Tailwind p-6 */
            box-shadow: 0 0 15px rgba(236, 72, 153, 0.3); /* Pink glow */
            display: none; /* Hidden by default */
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
        .phase.active {
            display: block;
            opacity: 1;
        }
        .sprint {
            background-color: #334155; /* Tailwind slate-700 */
            border: 1px solid #db2777; /* Tailwind pink-600 */
            border-radius: 0.375rem; /* Tailwind rounded-md */
            margin-top: 1.5rem; /* Tailwind mt-6 */
            padding: 1.5rem; /* Tailwind p-6 */
        }
        .sprint-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem; /* Tailwind mb-4 */
        }
        .sprint-title {
            font-size: 1.5rem; /* Tailwind text-2xl for VT323 */
            font-weight: normal; /* VT323 is often bold by default */
            color: #f472b6; /* Tailwind pink-400 */
        }
        .progress-bar-container {
            width: 120px; /* Increased width */
            height: 12px; /* Increased height */
            background-color: #475569; /* Tailwind slate-600 */
            border-radius: 0.125rem; /* Tailwind rounded-sm for pixel feel */
            border: 1px solid #ec4899; /* Pink border */
            overflow: hidden;
        }
        .progress-bar {
            height: 100%;
            background-color: #22d3ee; /* Tailwind cyan-400 */
            transition: width 0.3s ease-in-out;
        }
        .section-title { /* For "Implementations:" and "Key Tests to Pass for Delivery:" */
            font-size: 1.25rem; /* Tailwind text-xl for VT323 */
            font-weight: normal;
            color: #fda4af; /* Tailwind rose-300 */
            margin-top: 1rem; /* Tailwind mt-4 */
            margin-bottom: 0.5rem; /* Tailwind mb-2 */
        }

        /* Styling for checkable items (both Implementations and Key Tests) */
        .checkable-item {
            display: flex;
            align-items: flex-start; /* Align items to the start for multi-line labels */
            padding: 0.5rem 0;
            border-bottom: 1px dashed #475569; /* Tailwind border-slate-600 dashed */
        }
        .checkable-item:last-child {
            border-bottom: none;
        }
        .checkable-item input[type="checkbox"] {
            margin-right: 0.75rem;
            margin-top: 0.25rem; /* Align checkbox with first line of text */
            width: 1.25rem;
            height: 1.25rem;
            min-width: 1.25rem;
            appearance: none;
            border-radius: 2px;
            /* cursor: pointer; REMOVED - now disabled */
            position: relative;
            border: 1px solid #f472b6;
            background-color: #334155;
        }
        .checkable-item label {
            color: #e2e8f0;
            font-size: 1rem;
            line-height: 1.4;
        }
        .checkable-item.completed label {
            text-decoration: line-through;
            color: #64748b;
        }

        /* Specific styling for "Implementations" checkboxes (DONE = Pink X) */
        .implementation-item input[type="checkbox"]:checked {
            background-color: #ec4899;
            border-color: #ec4899;
        }
        .implementation-item input[type="checkbox"]:checked::after {
            content: 'X';
            color: #1e293b;
            font-size: 0.9rem;
            font-weight: bold;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Press Start 2P', cursive;
        }

        /* Specific styling for "Key Tests" checkboxes (PASSED = Green Check) */
        .key-test-item input[type="checkbox"] {
            border: 1px solid #34d399;
        }
        .key-test-item input[type="checkbox"]:checked {
            background-color: #10b981;
            border-color: #10b981;
        }
        .key-test-item input[type="checkbox"]:checked::after {
            content: 'âœ”';
            color: #ffffff;
            font-size: 1.1rem;
            font-weight: bold;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'VT323', monospace;
        }
        .key-test-item.completed label {
            color: #6ee7b7;
            text-decoration: none;
        }


        .phase-header {
            font-size: 1.75rem;
            font-weight: normal;
            color: #ec4899;
            margin-bottom: 1.5rem;
            padding-bottom: 0.75rem;
            border-bottom: 3px dashed #db2777;
            text-shadow: 0 0 8px rgba(236, 72, 153, 0.5);
        }
        .overall-progress-container {
            background-color: #1e293b;
            padding: 1.5rem;
            border-radius: 0.375rem;
            box-shadow: 0 0 20px rgba(236, 72, 153, 0.4);
            margin-bottom: 0.5rem; /* Reduced margin to make space for legend */
            border: 2px solid #ec4899;
        }
        .overall-progress-title {
            font-size: 1.5rem;
            font-weight: normal;
            color: #f472b6;
            margin-bottom: 1rem;
            text-align: center;
        }
        .overall-progress-bar-bg {
            height: 24px;
            background-color: #334155;
            border-radius: 0.125rem;
            overflow: hidden;
            border: 1px solid #ec4899;
            position: relative; /* For positioning milestone markers */
        }
        .overall-progress-bar-fg {
            height: 100%;
            background-color: #10b981;
            transition: width 0.5s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #ffffff;
            font-size: 0.875rem;
            font-weight: normal;
        }
        .milestone-markers-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* So it doesn't interfere with clicks on the bar itself if any */
        }
        .milestone-marker {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 3px; /* Thickness of the marker */
            /* background-color will be set dynamically */
        }
        .milestone-legend {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 1rem;
            margin-top: 0.75rem;
            margin-bottom: 1.5rem;
            font-size: 0.875rem;
        }
        .legend-item {
            display: flex;
            align-items: center;
        }
        .legend-color-box {
            width: 12px;
            height: 12px;
            margin-right: 0.5rem;
            border: 1px solid #94a3b8; /* slate-400 */
        }


        .navigation-buttons {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2.5rem;
        }
        .nav-button {
            background-color: #ec4899;
            color: #1e293b;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.75rem;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.25rem;
            cursor: pointer;
            text-transform: uppercase;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 2px 0 #db2777;
        }
        .nav-button:hover:not(:disabled) {
            background-color: #f472b6;
            box-shadow: 0 2px 0 #ec4899;
        }
        .nav-button:active:not(:disabled) {
            background-color: #db2777;
            transform: translateY(1px);
            box-shadow: 0 1px 0 #db2777;
        }
        .nav-button:disabled {
            background-color: #475569;
            color: #94a3b8;
            cursor: not-allowed;
            box-shadow: 0 2px 0 #334155;
        }
    </style>
</head>
<body class="p-4 md:p-8 font-vt323">

<div class="max-w-5xl mx-auto">
    <header class="text-center mb-12">
        <h1 class="text-5xl font-press-start text-pink-400" style="text-shadow: 0 0 10px #ec4899, 0 0 5px #ec4899;">Backend Roadmap</h1>
    </header>

    <div id="overallProgressContainer" class="overall-progress-container">
        <h2 class="overall-progress-title font-vt323">Project XP Bar</h2>
        <div class="overall-progress-bar-bg">
            <div id="overallProgressBar" class="overall-progress-bar-fg font-vt323" style="width: 0%;">0%</div>
            <div id="milestoneMarkersContainer" class="milestone-markers-container"></div>
        </div>
        <div id="milestoneLegend" class="milestone-legend"></div>
    </div>

    <div class="navigation-buttons">
        <button id="prevPhaseBtn" class="nav-button">Prev Phase</button>
        <button id="nextPhaseBtn" class="nav-button">Next Phase</button>
    </div>

    <div id="roadmapContainer">
    </div>
</div>

<script>
    // Roadmap data - YOU WILL EDIT THE `done` and `passed` flags HERE
    const roadmapData = [
        { // Phase 1
            phaseTitle: "Phase 1: Foundation Building",
            sprints: [
                { // Sprint 1
                    sprintTitle: "Sprint 1: Project Setup & Core Architecture",
                    implementations: [
                        { text: "Initialize Git repository with a clear branching strategy (e.g., Gitflow).", done: false },
                        { text: "Set up Node.js project with `package.json`, defining scripts for dev, test, lint, start.", done: false },
                        { text: "Configure linter (ESLint) and formatter (Prettier) and integrate into pre-commit hooks if possible.", done: false },
                        { text: "Establish the modular monolith project structure (`src`, `src/modules`, `src/config`, `src/middleware`, `src/utils`, `tests`) as per `project-structure.md`.", done: false },
                        { text: "Create `Dockerfile` and `docker-compose.yml` for local development (Node.js app, MongoDB instance).", done: false },
                        { text: "Write initial `README.md`, development standards, and setup guide.", done: false },
                        { text: "Implement a basic Express.js server (`src/app.js`, `src/server.js`) with a health check endpoint (`/health`).", done: false },
                        { text: "Define core module boundaries and initial inter-module communication patterns (direct service calls, placeholders for future event bus).", done: false },
                        { text: "Design JWT authentication strategy: token structure, generation, verification, expiry, refresh token mechanism, and secure client-side storage considerations.", done: false },
                        { text: "Set up `.env` file system for local environment variables (`.env.example` committed, `.env` gitignored).", done: false },
                        { text: "Establish a strict policy against committing any secrets. Document how secrets will be handled in staging/production later.", done: false },
                        { text: "Implement a logging library for structured JSON logs. Implement a request tracer ID.", done: false },
                        { text: "Implement centralized error handling middleware. Define initial custom error classes.", done: false },
                        { text: "Basic health check endpoint. Think about what 1-2 critical metrics could be logged.", done: false },
                        { text: "Choose and set up a database migration tool. Create an initial (empty) migration.", done: false },
                        { text: "Set up testing frameworks. Write initial setup tests and tests for health check and error handling.", done: false },
                        { text: "Configure GitHub Actions for linting, running tests, and potentially building a Docker image.", done: false },
                        { text: "Start thinking about data minimization for any user-related information.", done: false }
                    ],
                    keyTests: [
                        { text: "CI/CD pipeline successfully completes (linting, placeholder tests pass).", passed: false },
                        { text: "Local development environment (Dockerized) builds and the application starts correctly.", passed: false },
                        { text: "`/health` endpoint returns `200 OK` with expected status information.", passed: false },
                        { text: "Structured logging (e.g., JSON with request ID) is implemented and visible for basic requests.", passed: false },
                        { text: "Basic error handling middleware correctly formats a known type of error.", passed: false },
                        { text: "Database migration tool can connect and execute an initial migration successfully.", passed: false },
                        { text: "Project adheres to configured ESLint and Prettier standards.", passed: false }
                    ]
                },
                { // Sprint 2
                    sprintTitle: "Sprint 2: User Management Foundations",
                    implementations: [
                        { text: "Define the `User` schema in MongoDB (`database-models.md`) using Mongoose...", done: false },
                        { text: "Ensure only necessary personal data is captured...", done: false },
                        { text: "Registration endpoint (`/api/auth/register`): Input validation, Password hashing, Save user, Generate JWT...", done: false },
                        { text: "Login endpoint (`/api/auth/login`): Input validation, Verify credentials, Generate JWT...", done: false },
                        { text: "If sending welcome emails, securely manage email service credentials.", done: false },
                        { text: "Implement middleware to verify JWT on protected routes, attach `req.user`.", done: false },
                        { text: "Basic CRUD: Get current user profile; Update current user profile.", done: false },
                        { text: "Password Reset Functionality: Request endpoint; Confirmation endpoint.", done: false },
                        { text: "Log user registration, login, logout, and password reset attempts.", done: false },
                        { text: "Implement specific error responses for auth failures.", done: false },
                        { text: "Unit tests for `AuthService`, `UserService`.", done: false },
                        { text: "Integration tests for API endpoints. Test JWT protection.", done: false },
                        { text: "Update `api-specs.md` for all new endpoints.", done: false }
                    ],
                    keyTests: [
                        { text: "Unit Tests: `AuthService`, `UserService` logic.", passed: false },
                        { text: "API/Integration Tests: Successful user registration; error for duplicates/invalid input.", passed: false },
                        { text: "Successful user login; 401/400 for incorrect credentials.", passed: false },
                        { text: "JWT is returned on successful registration/login.", passed: false },
                        { text: "Protected user profile endpoint (`/api/users/me`) is accessible with a valid JWT.", passed: false },
                        { text: "Protected user profile endpoint is inaccessible without/invalid JWT.", passed: false },
                        { text: "User can update their own profile; validation errors for invalid updates.", passed: false },
                        { text: "Password reset request and confirmation endpoints function correctly.", passed: false },
                        { text: "All API endpoints return responses in the standard success/error JSON format.", passed: false },
                        { text: "Passwords are confirmed to be stored hashed (bcrypt) in the database.", passed: false }
                    ]
                },
                { // Sprint 3
                    sprintTitle: "Sprint 3: Game Data Integration",
                    implementations: [
                        { text: "Define `Game` schema (`database-models.md`).", done: false },
                        { text: "Develop integration with an external game API (IGDB/RAWG).", done: false },
                        { text: "Securely store external API keys.", done: false },
                        { text: "Implement game search/filtering API endpoints.", done: false },
                        { text: "Implement a background job for periodic game data updates.", done: false },
                        { text: "Robustly handle failures from the external API during sync.", done: false },
                        { text: "Log sync jobs. Monitor health and performance.", done: false },
                        { text: "Implement a caching layer for game data.", done: false },
                        { text: "Unit tests for `GameService`, mocking external API calls. Test caching and background job logic.", done: false },
                        { text: "Update `api-specs.md`.", done: false }
                    ],
                    keyTests: [
                        { text: "Unit Tests: `GameService` logic (fetching, searching, filtering, mocked API, caching).", passed: false },
                        { text: "API/Integration Tests: `/api/games` and `/api/games/{gameId}` endpoints work correctly.", passed: false },
                        { text: "Background Job Test: Game data sync job fetches and updates data correctly.", passed: false },
                        { text: "Caching for game data is functional.", passed: false },
                        { text: "Secure storage and usage of external API keys.", passed: false }
                    ]
                },
                { // Sprint 4
                    sprintTitle: "Sprint 4: Profile Enhancement & Admin Foundations",
                    implementations: [
                        { text: "Extend `User` schema: `gamingPreferences`, `gameProfiles`.", done: false },
                        { text: "Implement APIs to update these new profile sections.", done: false },
                        { text: "Consider visibility settings for new profile fields.", done: false },
                        { text: "Implement RBAC middleware.", done: false },
                        { text: "Create `admin` module with `AdminController` and `AdminService`.", done: false },
                        { text: "Admin User Management: APIs for list, view details, update status.", done: false },
                        { text: "Securely log all admin actions (audit trail).", done: false },
                        { text: "Define `Report` schema. API for users to submit reports. Admin APIs for report management.", done: false },
                        { text: "Ensure admin APIs provide enough information for action.", done: false },
                        { text: "Define `Friendship` schema. Implement backend logic for sending a friend request.", done: false },
                        { text: "Ensure admin endpoints are rigorously protected by RBAC and validated.", done: false },
                        { text: "Unit/integration tests for new profile features, admin functionalities, RBAC, reporting.", done: false },
                        { text: "Update API documentation.", done: false }
                    ],
                    keyTests: [
                        { text: "Unit Tests: Logic for updating extended user profiles; RBAC checking logic.", passed: false },
                        { text: "API/Integration Tests (User Profile): Users can update preferences and game profiles. Validation works.", passed: false },
                        { text: "API/Integration Tests (Admin): Admin APIs are accessible only by 'admin' role. Admins can manage users.", passed: false },
                        { text: "Users can submit a report. Admins can manage reports.", passed: false },
                        { text: "Friendship: Users can send a friend request; 'pending' record created.", passed: false },
                        { text: "Audit logs for admin actions are created correctly.", passed: false }
                    ]
                }
            ]
        },
        { // Phase 2
            phaseTitle: "Phase 2: Core Matchmaking System",
            sprints: [
                { // Sprint 5
                    sprintTitle: "Sprint 5: Matchmaking Algorithm Foundation",
                    implementations: [
                        { text: "Define `MatchRequest` schema. Define `PlayerSkill/Rank` data structures.", done: false },
                        { text: "APIs for users to submit and cancel matchmaking requests. Consider idempotency.", done: false },
                        { text: "Algorithm: Core criteria (game, mode, region). Simple skill matching. Implement basic `calculateCompatibilityScore`.", done: false },
                        { text: "Implement in-memory matchmaking queue (or Redis lists).", done: false },
                        { text: "Define `MatchHistory` schema. Implement basic tracking.", done: false },
                        { text: "Develop framework to feed sample `MatchRequest` data to algorithm.", done: false },
                        { text: "Log new match requests, cancellations, algorithm processing cycles, queue lengths.", done: false },
                        { text: "Error Handling for matchmaking submissions and processing.", done: false },
                        { text: "Update API documentation.", done: false }
                    ],
                    keyTests: [
                        { text: "Unit Tests: Core logic of `MatchAlgorithmService` (compatibility scoring, basic match formation). Test queue management.", passed: false },
                        { text: "API/Integration Tests: Users can submit/cancel matchmaking requests. Invalid criteria rejected.", passed: false },
                        { text: "Algorithm Simulation: Users with compatible criteria are matched. Skill considered. `MatchHistory` record created.", passed: false },
                        { text: "Logging for new match requests, cancellations, and basic algorithm processing steps is present.", passed: false }
                    ]
                },
                { // Sprint 6
                    sprintTitle: "Sprint 6: Real-time Communication",
                    implementations: [
                        { text: "Integrate Socket.IO into the Express server, managed by `SocketManager` (as per `real-time-communication.md`).", done: false },
                        { text: "Implement JWT-based authentication for Socket.IO connections.", done: false },
                        { text: "Track active sockets per user (`userSockets` Map: userId -> Set<socketId>). Handle multiple connections from the same user.", done: false },
                        { text: "On connect: Mark user 'online', join user-specific room (e.g., `user:${userId}`).", done: false },
                        { text: "On disconnect: Update user status if no other active connections.", done: false },
                        { text: "Emit `user:status` events to relevant clients (e.g., friends, if friend system is more developed) when status changes.", done: false },
                        { text: "Client event `matchmaking:subscribe` { requestId }. Server joins socket to `match:${requestId}` room.", done: false },
                        { text: "Server emits `matchmaking:status` events (status, searchTime, potentialMatches, estimatedTime) to the `match:${requestId}` room or user-specific room.", done: false },
                        { text: "Formalize event names and payload structures in `real-time-communication.md`.", done: false },
                        { text: "Log socket connection/authentication success/failure, disconnections. Log key events emitted and received (with sanitized data). Monitor active Socket.IO connection count.", done: false },
                        { text: "Error Handling: For socket authentication, event handling, and emissions. What happens if an event fails to send?", done: false },
                        { text: "Develop/use utilities (`socket.io-client` in tests) for WebSocket functionality. Test connection, auth, event emission/reception for matchmaking status. Test presence updates.", done: false },
                        { text: "Make Socket.IO settings (e.g., ping timeouts, CORS origins) configurable.", done: false }
                    ],
                    keyTests: [
                        { text: "Connection & Auth: Client successfully connects to Socket.IO with a valid JWT; connection is rejected with an invalid/missing JWT.", passed: false },
                        { text: "User Presence: When a client connects, their status is updated to 'online' (verify internally, e.g., in `userSockets` map or DB). If implemented, `user:status` events are emitted to relevant clients. When a client disconnects (and it's their last connection), their status is updated to 'offline'.", passed: false },
                        { text: "Matchmaking Status Updates: Client can emit `matchmaking:subscribe` with a `requestId`. Server correctly joins the client's socket to the appropriate room for that request. When matchmaking logic (can be mocked for this test) processes a request, the server emits `matchmaking:status` events to the subscribed client with correct payload.", passed: false },
                        { text: "Socket.IO event handlers deal with malformed payloads gracefully.", passed: false },
                        { text: "Logging for socket connections, disconnections, and key events is implemented.", passed: false }
                    ]
                },
                { // Sprint 7
                    sprintTitle: "Sprint 7: Lobby System",
                    implementations: [
                        { text: "Define `Lobby` schema: name, status (forming, ready, active, closed), game details, members (userId, status, isHost, readyStatus), capacity, chat settings, autoMessage, timestamps.", done: false },
                        { text: "Define `Chat` schema for lobby chat: chatType ('lobby'), participants, lobbyId, messages array (or separate Message collection).", done: false },
                        { text: "`MatchmakingService` calls `LobbyService.createLobby()` upon finding a match.", done: false },
                        { text: "Ensure lobby creation from a match event is idempotent.", done: false },
                        { text: "Implement lobby state machine (forming -> ready -> active -> closed) logic within `LobbyService`.", done: false },
                        { text: "APIs for joining (`/api/lobbies/{lobbyId}/join` - may be automatic post-match) and leaving (`/api/lobbies/{lobbyId}/leave`).", done: false },
                        { text: "Socket.IO events for real-time updates: `lobby:update`, `lobby:member:joined`, `lobby:member:left`, `lobby:member:ready`.", done: false },
                        { text: "\"Ready\" functionality: API (`/api/lobbies/{lobbyId}/ready`) and socket event (`lobby:member:ready`). `LobbyService` checks if all members are ready to transition lobby state.", done: false },
                        { text: "`ChatService` integration: create a chat room when a lobby is created.", done: false },
                        { text: "Socket.IO events for sending/receiving lobby chat messages (`chat:message`, `chat:typing` as per `real-time-communication.md`). Store messages.", done: false },
                        { text: "Implement system for predefined lobby messages.", done: false },
                        { text: "Log lobby creation, member joins/leaves, status changes, chat messages (sanitized). Audit trail of important lobby events.", done: false },
                        { text: "Error Handling: For lobby creation, member management, state transitions.", done: false },
                        { text: "Unit/integration tests for lobby lifecycle, member actions, chat functionality. Test concurrent operations.", done: false },
                        { text: "Update relevant documents.", done: false }
                    ],
                    keyTests: [
                        { text: "Unit Tests: `LobbyService` state machine logic; member management logic.", passed: false },
                        { text: "Integration/API Tests: Successful lobby creation when matchmaking (mocked) finds a match. Users (lobby members) can set their ready status via API. Users can leave a lobby via API.", passed: false },
                        { text: "Socket.IO Tests: Clients receive `lobby:update` events. Clients receive `lobby:member:joined`, `lobby:member:left`, `lobby:member:ready` events. Basic lobby chat: messages sent via `chat:message` socket event are received by other connected lobby members; messages are persisted.", passed: false },
                        { text: "Test \"all members ready\" condition correctly transitions lobby state.", passed: false },
                        { text: "Idempotency test for lobby creation from a match event.", passed: false }
                    ]
                },
                { // Sprint 8
                    sprintTitle: "Sprint 8: Notification System",
                    implementations: [
                        { text: "Define `Notification` schema: userId, type, title, message, data, status, deliveryChannels, deliveryStatus.", done: false },
                        { text: "`NotificationService.createNotification()`: Core logic to create and dispatch notifications.", done: false },
                        { text: "APIs for users: get notifications, mark as read/all read, get count.", done: false },
                        { text: "Extend `User` schema for `notificationSettings`. API to update these settings. `NotificationService` must check these preferences.", done: false },
                        { text: "In-app: `NotificationService` uses `SocketManager` to send `notification:new` and `notification:count` events.", done: false },
                        { text: "Push Notifications (Firebase/FCM): API to register/unregister device tokens, store in `User.deviceTokens`. `NotificationService` integrates with FCM SDK. Sending push notifications should be offloaded to a job queue. Securely store FCM server key.", done: false },
                        { text: "Email Notifications (Basic): Integrate an email service. `NotificationService` to send emails. Email sending should also be a background job. Consider email deliverability and bounce handling.", done: false },
                        { text: "Integrate `NotificationService.createNotification()` calls in relevant services (Matchmaking, Friend, Lobby, Chat).", done: false },
                        { text: "Update `deliveryStatus` in `Notification` model.", done: false },
                        { text: "Log notification creation, targeted delivery channels, and delivery success/failure for each channel.", done: false },
                        { text: "Error Handling: For failures in sending notifications via any channel.", done: false },
                        { text: "Ensure notification content is appropriate and preferences are strictly adhered to.", done: false },
                        { text: "Mock external push/email services. Test notification creation, preference checks, and in-app delivery via sockets.", done: false },
                        { text: "Update API & WebSocket Documentation.", done: false }
                    ],
                    keyTests: [
                        { text: "Unit Tests: `NotificationService` logic for checking user preferences before sending; dispatch logic for different channels (mocking external services).", passed: false },
                        { text: "API/Integration Tests: Users can retrieve their notifications, mark as read, get unread count, update notification preferences.", passed: false },
                        { text: "In-App Notification Test (Socket.IO): When a notification is created and user has in-app notifications enabled, they receive `notification:new` and `notification:count` events.", passed: false },
                        { text: "Push/Email Channel Tests (Mocked Senders): Verify `NotificationService` *attempts* to send a push/email if user has it enabled.", passed: false },
                        { text: "Trigger Tests: When a key event occurs, a corresponding `Notification` document is created.", passed: false },
                        { text: "Background jobs for sending push/email notifications are triggered and process items from a queue.", passed: false },
                        { text: "`Notification.deliveryStatus` is updated correctly after attempting delivery.", passed: false }
                    ]
                }
            ]
        },
        { // Phase 3
            phaseTitle: "Phase 3: Feature Enrichment",
            sprints: [
                { // Sprint 9
                    sprintTitle: "Sprint 9: Advanced Matchmaking Features",
                    implementations: [
                        { text: "Multi-game matching: Modify algorithm to consider `MatchRequest.criteria.games` (array with weights). `calculateGameMatchScore` needs to use these weights.", done: false },
                        { text: "Tiered matching (fallbacks): Formalize and implement criteria relaxation strategy (`relaxCriteria` function in `MatchmakingService`). `MatchRequest` needs `relaxationLevel` and `relaxationTimestamp`. Periodically check and relax criteria for long-waiting requests.", done: false },
                        { text: "Region/Language matching: Implement `calculateRegionMatchScore` and `calculateLanguageMatchScore` thoroughly, using `User.preferences` and `MatchRequest.criteria`.", done: false },
                        { text: "Handle `MatchRequest.criteria.scheduledTime`. `MatchmakingService` needs a separate queue/logic for these, triggering matching closer to `scheduledTime`.", done: false },
                        { text: "Utilize `MatchRequest.preselectedUsers`. Algorithm must try to keep these groups intact. Implement `groupPreselectedUsers` logic.", done: false },
                        { text: "API to add friends to an active matchmaking request (`/api/matchmaking/{requestId}/friends`).", done: false },
                        { text: "Develop more complex test data for the matchmaking algorithm. Profile the matchmaking process under simulated load. Optimize database queries and algorithmic complexity.", done: false },
                        { text: "Log detailed metrics about matchmaking rounds: number of users processed, average compatibility scores, time taken, relaxation levels reached.", done: false },
                        { text: "Review \"add friends to matchmaking\" and other update operations for idempotency.", done: false },
                        { text: "Create specific test cases for multi-game, tiered matching, scheduled matching, and group matchmaking scenarios.", done: false },
                        { text: "Update any changes to matchmaking request/response.", done: false }
                    ],
                    keyTests: [
                        { text: "Algorithm Validation (Expanded Scenarios): Multi-game, Tiered Matching/Relaxation, Region/Language, Planned Matchmaking, Pre-made Group.", passed: false },
                        { text: "API Tests: `/api/matchmaking/{requestId}/friends` endpoint successfully adds friends to an ongoing matchmaking request.", passed: false },
                        { text: "Performance of the advanced algorithm with more complex data sets is within acceptable limits for this stage.", passed: false },
                        { text: "Logging shows details of criteria relaxation and weighted considerations.", passed: false }
                    ]
                },
                { // Sprint 10
                    sprintTitle: "Sprint 10: Social Features Enhancement",
                    implementations: [
                        { text: "Implement APIs: send request, list pending requests, accept/reject, remove friend.", done: false },
                        { text: "Update `Friendship` status. Trigger notifications for friend requests and acceptances.", done: false },
                        { text: "Sending a friend request or blocking a user should ideally be idempotent.", done: false },
                        { text: "API to get user's friends.", done: false },
                        { text: "API to block a user (updates `Friendship` to 'blocked'). API to unblock. API to get blocked users.", done: false },
                        { text: "Blocked users should not appear in matchmaking results for each other, nor be able to send messages/friend requests.", done: false },
                        { text: "Enable creation of 'direct' type chats. API to get/create direct chat with a user. API to list all user's chats. Socket.IO events for direct messages.", done: false },
                        { text: "Define `UserActivity` schema. Implement `UserActivityService.logActivity()` called from various services.", done: false },
                        { text: "Ensure activity tracking is disclosed and, if necessary, configurable by the user.", done: false },
                        { text: "Add `karmaPoints` to `User` schema. API for users to give karma post-match/interaction. `KarmaService` to handle karma updates and prevent abuse.", done: false },
                        { text: "Admins may need to review/mediate reported interactions or karma abuse. Consider if any specific admin APIs are needed here.", done: false },
                        { text: "Test all friend operations, blocking logic, DM functionality, activity logging, and karma updates.", done: false },
                        { text: "Update API & WebSocket Documentation.", done: false }
                    ],
                    keyTests: [
                        { text: "API/Integration Tests (Friends): Send request, accept/reject, remove friend. Notifications sent.", passed: false },
                        { text: "API/Integration Tests (Blocking): Block/unblock user. Blocked users cannot interact.", passed: false },
                        { text: "API/Integration Tests (Direct Messaging): Initiate/retrieve direct chat. Messages sent/received and persisted.", passed: false },
                        { text: "User Activity Logging: Key social actions are correctly logged.", passed: false },
                        { text: "Karma System: Users can submit karma; target user's karma points are updated; basic abuse prevention is in place.", passed: false },
                        { text: "Test that appropriate notifications are triggered for friend requests/acceptances.", passed: false }
                    ]
                },
                { // Sprint 11
                    sprintTitle: "Sprint 11: Rich Media & Content",
                    implementations: [
                        { text: "API endpoint for profile image upload. API endpoint for chat media upload. Use `multer`.", done: false },
                        { text: "Rigorous file type validation, size limits. Consider malware scanning.", done: false },
                        { text: "Integrate SDK for chosen cloud storage. `StorageService` to handle uploads, deletions. Store URLs/keys in `User.profileImage` or `Message.mediaUrl`.", done: false },
                        { text: "Securely store cloud storage credentials.", done: false },
                        { text: "For image uploads (avatars), use a library like `sharp` for server-side resizing and basic optimization. This should be done asynchronously.", done: false },
                        { text: "Backend: Ensure `Message.content` can store UTF-8 emojis. `Message.contentType` to support 'emoji', 'gif'.", done: false },
                        { text: "When media is uploaded, publish an event that a separate moderation service can subscribe to. Update media records with a moderation status. Only show approved media.", done: false },
                        { text: "Admins need a way to review media flagged by hooks or reports, and approve/reject/delete it.", done: false },
                        { text: "Configure cloud storage to serve files via a CDN. Ensure generated URLs point to CDN.", done: false },
                        { text: "Log media uploads, processing job status.", done: false },
                        { text: "Test file uploads, storage integration, basic processing. Test moderation hooks.", done: false },
                        { text: "Update API Documentation.", done: false }
                    ],
                    keyTests: [
                        { text: "API/Integration Tests (Uploads): Users can successfully upload valid profile images; `User.profileImage` is updated. Users can successfully upload valid media files to chat; `Message.mediaUrl` is populated. Uploads of invalid file types or oversized files are rejected.", passed: false },
                        { text: "Storage Integration: Verify that uploaded files are correctly stored in cloud storage.", passed: false },
                        { text: "Background Job Tests (Media Processing): Image resizing job processes newly uploaded images.", passed: false },
                        { text: "Chat: Messages containing emojis and valid GIF URLs are stored and can be retrieved.", passed: false },
                        { text: "Content Moderation Hooks: An event is emitted when new media is successfully uploaded.", passed: false },
                        { text: "(If CDN configured) Verify that URLs served for media point to the CDN.", passed: false }
                    ]
                },
                { // Sprint 12
                    sprintTitle: "Sprint 12: Analytics & Insights Foundation",
                    implementations: [
                        { text: "Solidify `UserActivity` logging or introduce a dedicated `AnalyticsEvent` collection. Define a clear schema for events.", done: false },
                        { text: "Ensure services are consistently emitting these events for key actions.", done: false },
                        { text: "Design schemas for pre-aggregated data (DAU, MAU, popular games, matchmaking success rates, average wait times). Implement background jobs to calculate and store these aggregates periodically.", done: false },
                        { text: "Create secure admin APIs to fetch these aggregated metrics for an internal dashboard.", done: false },
                        { text: "Define and track: session duration, feature usage counts.", done: false },
                        { text: "Log and aggregate: avg wait times, match completion rates, distribution of relaxation levels reached before matching.", done: false },
                        { text: "Integrate with APM tools if available, or ensure logs are detailed enough for performance analysis.", done: false },
                        { text: "Ensure logs are structured for easy parsing by analytics tools or scripts.", done: false },
                        { text: "Ensure all analytics data collection is compliant with privacy policies. Anonymize or pseudonymize data used for general platform statistics where individual user identification is not necessary.", done: false },
                        { text: "Test event emission, background aggregation jobs, and accuracy of admin stat APIs.", done: false },
                        { text: "Document admin stats APIs.", done: false }
                    ],
                    keyTests: [
                        { text: "Event Tracking: Key business events are correctly emitted and stored.", passed: false },
                        { text: "Aggregation Job Tests: Background jobs that calculate daily/weekly aggregates run correctly and produce accurate data.", passed: false },
                        { text: "Admin Dashboard API Tests: Admin-only APIs for fetching key metrics return correct aggregated data and are properly secured.", passed: false },
                        { text: "Verify that metrics for user engagement and matchmaking effectiveness are being collected or can be derived.", passed: false },
                        { text: "If anonymization/pseudonymization is implemented for public stats, verify it's working.", passed: false }
                    ]
                }
            ]
        },
        { // Phase 4
            phaseTitle: "Phase 4: Monetization & Advanced Features",
            sprints: [
                { // Sprint 13
                    sprintTitle: "Sprint 13: Shop System Foundation",
                    implementations: [
                        { text: "`ShopItem` schema: type, name, description, imageUrl, price {amount, currency ('virtual')}, rarity, availability. `UserInventory` schema: userId, items. Add `virtualCurrencyBalance` to `User` schema.", done: false },
                        { text: "APIs for Browse/filtering shop items. API to get user's inventory.", done: false },
                        { text: "API to purchase an item using virtual currency. `ShopService` to: Verify item, Check balance, Deduct currency, Add item to `UserInventory`. Ensure purchasing an item is idempotent.", done: false },
                        { text: "APIs to equip/unequip items. `InventoryService` updates `UserInventory`. `UserService` or `ProfileService` logic to reflect equipped items on user profile.", done: false },
                        { text: "Backend APIs/tools for admins to: CRUD shop items. View/manage user virtual currency balances. View/manage user inventories.", done: false },
                        { text: "Log all shop transactions, inventory changes, virtual currency balance updates.", done: false },
                        { text: "Test item creation, listing, purchase, inventory updates, equipping/unequipping.", done: false },
                        { text: "Update API Documentation.", done: false }
                    ],
                    keyTests: [
                        { text: "API/Integration Tests (Shop & Inventory): Users can browse/filter shop items. Users can view their inventory. Users can purchase items using virtual currency (succeeds/fails correctly). Users can equip/unequip items.", passed: false },
                        { text: "Admin APIs: Admins can CRUD shop items; admins can view/adjust user virtual currency and inventories.", passed: false },
                        { text: "Idempotency: Purchasing an item with virtual currency is idempotent.", passed: false },
                        { text: "Audit logs for all shop transactions, inventory changes, and virtual currency balance adjustments are created.", passed: false }
                    ]
                },
                { // Sprint 14
                    sprintTitle: "Sprint 14: Payment Integration",
                    implementations: [
                        { text: "Choose provider (Stripe, etc.). Integrate their SDK. Securely store API keys.", done: false },
                        { text: "API endpoint to create payment intent. Backend communicates with provider, returns client secret/ID to frontend.", done: false },
                        { text: "Frontend uses client secret to complete payment with provider.", done: false },
                        { text: "Secure webhook endpoint to receive payment success/failure/dispute notifications. Process webhooks idempotently. Verify webhook signatures.", done: false },
                        { text: "`Transaction` schema: userId, itemId/packId, amount, currency ('real'), paymentProviderTransactionId, status, timestamps.", done: false },
                        { text: "Upon successful payment confirmation, update user's virtual currency or grant item to inventory.", done: false },
                        { text: "API for users to view their real-money transaction history.", done: false },
                        { text: "Adhere to PCI DSS compliance standards. Never store raw credit card details. Protect against fraud.", done: false },
                        { text: "Admin-initiated refunds. Backend API to trigger refund via payment provider API. Update `Transaction` status. Admin interface to view transactions and manage refunds.", done: false },
                        { text: "Understand tax implications, consumer rights for digital purchases.", done: false },
                        { text: "Detailed, secure audit trail for all payment intents, transactions, webhook events, and fulfillment actions.", done: false },
                        { text: "Requires careful setup. Use provider's test modes and mock card numbers. Test full lifecycle. Test failure scenarios.", done: false },
                        { text: "Update API Documentation.", done: false }
                    ],
                    keyTests: [
                        { text: "API/Integration Tests: User can initiate a purchase for a real-money item/virtual currency pack; backend successfully creates a payment intent. Webhook Handling: Successful payment webhook updates transaction, grants entitlement (idempotent). Failed payment webhook updates transaction. Dispute/refund webhook updates transaction.", passed: false },
                        { text: "Users can view their real-money transaction history.", passed: false },
                        { text: "Security: Webhook endpoint is secure and validates incoming requests. No sensitive cardholder data is logged or stored.", passed: false },
                        { text: "Admin APIs: Admins can view transaction details. Admin-initiated refund process updates transaction status.", passed: false },
                        { text: "Full end-to-end payment flow works correctly in the test environment.", passed: false },
                        { text: "Critical payment operations are logged for auditing.", passed: false }
                    ]
                },
                { // Sprint 15
                    sprintTitle: "Sprint 15: Dashboard & Exploration Features",
                    implementations: [
                        { text: "`FeedItem` schema. `FeedService` to generate feed items based on `UserActivity`. Fan-out approach for friend activities.", done: false },
                        { text: "API for users to retrieve their personalized feed with pagination.", done: false },
                        { text: "Reuse external game API or find news-specific APIs. Background job to fetch and cache news for games users play/follow. API for users to get relevant game news.", done: false },
                        { text: "Leverage aggregated analytics from Sprint 12. APIs to show interesting, anonymized platform stats.", done: false },
                        { text: "\"Games your friends play that you don't.\" \"Users with similar game preferences.\" Requires querying user profiles, friend lists, game data.", done: false },
                        { text: "Endpoints to find popular/trending games, public lobbies, maybe user-generated content.", done: false },
                        { text: "Feeds and dashboard data can be read-heavy. Implement aggressive caching. Optimize database queries.", done: false },
                        { text: "Monitor performance of feed generation and API response times for dashboard endpoints.", done: false },
                        { text: "Test feed generation logic, recommendation accuracy, API performance.", done: false },
                        { text: "Update API Documentation.", done: false }
                    ],
                    keyTests: [
                        { text: "API/Integration Tests: Personalized activity feed API returns relevant, paginated items. Game news API returns current news. Platform statistics APIs return accurate public data. Basic personalized recommendations API returns sensible suggestions.", passed: false },
                        { text: "Performance: APIs for feeds and dashboards respond within acceptable time limits, especially with caching enabled.", passed: false },
                        { text: "Test that feed generation logic correctly sources data from `UserActivity` and other relevant events.", passed: false }
                    ]
                },
                { // Sprint 16
                    sprintTitle: "Sprint 16: Advanced Security & Compliance",
                    implementations: [
                        { text: "Data Mapping: Review all PII stored, its purpose, legal basis for processing, and retention period.", done: false },
                        { text: "Right to Access: API and admin tool for users/admins to export all user data in a common format.", done: false },
                        { text: "Right to Erasure: API and admin tool for users/admins to request/perform account deletion. Handle content and references. Ensure data is removed from backups or anonymized. Log deletion requests.", done: false },
                        { text: "Consent Management: Implement mechanisms to record and withdraw consent if applicable.", done: false },
                        { text: "Review current rate limits. Implement more granular limits for sensitive operations. Use a persistent store like Redis for distributed rate limiting.", done: false },
                        { text: "Conduct internal code review focused on security. Use tools like `npm audit --recursive`, Snyk, or ESLint security plugins. Address identified vulnerabilities.", done: false },
                        { text: "Ensure backend logic aligns with the stated privacy policy.", done: false },
                        { text: "Verify MongoDB encryption at rest is active. Consider application-level encryption for specific, highly sensitive fields if necessary.", done: false },
                        { text: "Prepare documentation and environment for a future external penetration test.", done: false },
                        { text: "Maintain internal documentation of data flows, PII locations, security measures, and GDPR compliance efforts.", done: false },
                        { text: "The data export and deletion functionalities are critical admin tools. Ensure they are robust, auditable, and tested.", done: false },
                        { text: "Log all data access requests, export actions, and deletion actions for audit purposes.", done: false },
                        { text: "Thoroughly test data export and deletion. Simulate data subject requests. Test advanced rate-limiting.", done: false },
                        { text: "Document any user-facing APIs for data rights.", done: false }
                    ],
                    keyTests: [
                        { text: "GDPR Functionality Tests: Data Access/Export: Users can request and receive an export of their personal data. Data Erasure: Users can request account/data deletion; PII is verifiably removed/anonymized.", passed: false },
                        { text: "Advanced Rate Limiting: Stricter rate limits on sensitive operations are correctly enforced.", passed: false },
                        { text: "Verify that any vulnerabilities identified during internal audits or by security scanning tools have been addressed and re-tested.", passed: false },
                        { text: "Test that privacy policy enforcement mechanisms function correctly.", passed: false },
                        { text: "Audit logs for all data access requests, export actions, and deletion actions are comprehensive and accurate.", passed: false }
                    ]
                }
            ]
        },
        { // Phase 5
            phaseTitle: "Phase 5: Optimization & Scaling Preparation",
            sprints: [
                { // Sprint 17
                    sprintTitle: "Sprint 17: Performance Optimization",
                    implementations: [
                        { text: "Use MongoDB `explain()` on slow queries identified by APM or logging. Refine queries, ensure optimal index usage.", done: false },
                        { text: "Review all indexes. Add missing ones, remove unused/redundant ones. Analyze compound index effectiveness.", done: false },
                        { text: "Profile cache hit/miss ratios. Adjust TTLs. Ensure proper cache invalidation strategies. Consider different caching strategies.", done: false },
                        { text: "Profile resource usage and execution time of background jobs. Optimize logic, batch processing.", done: false },
                        { text: "Profile critical API endpoints. Identify and optimize bottlenecks. Consider asynchronous processing.", done: false },
                        { text: "Monitor CPU, memory, network, disk I/O under load. Identify and address leaks or excessive consumption.", done: false },
                        { text: "Use tools (Artillery, k6, JMeter) to simulate realistic concurrent user loads on critical flows. Identify system bottlenecks. Iteratively optimize and re-test.", done: false },
                        { text: "Use monitoring data to identify areas needing optimization. Log before/after states for optimization changes to measure impact.", done: false }
                    ],
                    keyTests: [
                        { text: "Load Tests: Critical APIs and user flows meet defined performance targets under simulated peak load.", passed: false },
                        { text: "Verification of Optimizations: Post-optimization, specific slow queries or bottlenecks identified earlier now show measurable improvement.", passed: false },
                        { text: "System resource usage remains stable and within acceptable limits during sustained load tests.", passed: false },
                        { text: "Cache hit rates for frequently accessed data are demonstrably improved where caching optimizations were applied.", passed: false }
                    ]
                },
                { // Sprint 18
                    sprintTitle: "Sprint 18: Cloud Deployment Preparation",
                    implementations: [
                        { text: "Write/refine IaC scripts (Terraform, CloudFormation, Pulumi) for provisioning all cloud resources.", done: false },
                        { text: "Finalize and test secure configuration and secret management for staging and production environments.", done: false },
                        { text: "Optimize production `Dockerfile`. Push images to a private container registry.", done: false },
                        { text: "Integrate with cloud provider's logging. Set up monitoring dashboards. Implement and test comprehensive alerting for production issues.", done: false },
                        { text: "Configure automated database backups. Define, document, and *test* the disaster recovery plan (Restore drills, Process for redeploying application).", done: false },
                        { text: "Automate deployments to staging and production using CI/CD pipeline. Implement strategies like blue/green or canary deployments if feasible. Include automated rollback procedures.", done: false },
                        { text: "Create initial runbooks for common operational tasks.", done: false },
                        { text: "Final Security Review for Production Setup: Check network security groups, firewall rules, IAM permissions in the cloud environment.", done: false }
                    ],
                    keyTests: [
                        { text: "IaC Deployment Test: IaC scripts successfully provision a complete staging environment.", passed: false },
                        { text: "Configuration Test: Deployed application in staging loads the correct environment-specific configurations and secrets.", passed: false },
                        { text: "Logging/Monitoring/Alerting Test (in Staging): Application logs are shipped. Metrics populate dashboards. Manually trigger test alerts; verify alerts are generated and routed.", passed: false },
                        { text: "Backup and Restore Drill (CRITICAL): Successfully perform a full backup of the staging database. Successfully restore this backup. Verify data integrity and application functionality.", passed: false },
                        { text: "Automated Deployment Test: CI/CD pipeline successfully deploys the latest stable build to staging. Verify zero-downtime if applicable. Test automated rollback if implemented.", passed: false },
                        { text: "Key operational procedures from the runbook are tested and validated in the staging environment.", passed: false }
                    ]
                }
            ]
        }
    ];

    const roadmapContainer = document.getElementById('roadmapContainer');
    const overallProgressBar = document.getElementById('overallProgressBar');
    const milestoneMarkersContainer = document.getElementById('milestoneMarkersContainer');
    const milestoneLegendContainer = document.getElementById('milestoneLegend');
    const prevPhaseBtn = document.getElementById('prevPhaseBtn');
    const nextPhaseBtn = document.getElementById('nextPhaseBtn');

    let currentPhaseIndex = 0;
    let phaseElements = [];
    const phaseColors = ["#FF69B4", "#ADFF2F", "#1E90FF", "#FFD700", "#FF4500", "#DA70D6"]; // Example colors for phases

    // Function to create HTML for a checkable "Implementation" item
    function createImplementationItemHTML(item, phaseIndex, sprintIndex, itemIndex) {
        const id = `impl-p${phaseIndex}-s${sprintIndex}-i${itemIndex}`;
        return `
                <div class="checkable-item implementation-item ${item.done ? 'completed' : ''}">
                    <input type="checkbox" id="${id}" data-type="implementation"
                           data-phase="${phaseIndex}" data-sprint="${sprintIndex}" data-item-index="${itemIndex}"
                           ${item.done ? 'checked' : ''} disabled>
                    <label for="${id}" class="font-vt323">${item.text}</label>
                </div>
            `;
    }

    // Function to create HTML for a checkable "Key Test" item
    function createKeyTestItemHTML(item, phaseIndex, sprintIndex, itemIndex) {
        const id = `test-p${phaseIndex}-s${sprintIndex}-t${itemIndex}`;
        return `
                <div class="checkable-item key-test-item ${item.passed ? 'completed' : ''}">
                    <input type="checkbox" id="${id}" data-type="key-test"
                           data-phase="${phaseIndex}" data-sprint="${sprintIndex}" data-item-index="${itemIndex}"
                           ${item.passed ? 'checked' : ''} disabled>
                    <label for="${id}" class="font-vt323">${item.text}</label>
                </div>
            `;
    }

    function createSprintHTML(sprint, phaseIndex, sprintIndex) {
        const sprintId = `p${phaseIndex}-s${sprintIndex}`;
        let implementationsHTML = '';
        sprint.implementations.forEach((item, itemIndex) => {
            implementationsHTML += createImplementationItemHTML(item, phaseIndex, sprintIndex, itemIndex);
        });

        let keyTestsHTML = '';
        sprint.keyTests.forEach((test, testIndex) => {
            keyTestsHTML += createKeyTestItemHTML(test, phaseIndex, sprintIndex, testIndex);
        });

        return `
                <div class="sprint" id="sprint-${sprintId}">
                    <div class="sprint-header">
                        <h3 class="sprint-title font-vt323">${sprint.sprintTitle}</h3>
                        <div class="progress-bar-container">
                            <div class="progress-bar" id="progress-${sprintId}" style="width: 0%;"></div>
                        </div>
                    </div>
                    <p class="section-title font-vt323">Implementations:</p>
                    ${implementationsHTML}
                    <h4 class="section-title font-vt323">Key Tests to Pass for Delivery:</h4>
                    ${keyTestsHTML}
                </div>
            `;
    }

    function createPhaseHTML(phase, phaseIndex) {
        let sprintsHTML = '';
        phase.sprints.forEach((sprint, sprintIndex) => {
            sprintsHTML += createSprintHTML(sprint, phaseIndex, sprintIndex);
        });

        return `
                <section class="phase" id="phase-${phaseIndex}">
                    <h2 class="phase-header font-press-start">${phase.phaseTitle}</h2>
                    ${sprintsHTML}
                </section>
            `;
    }

    function renderRoadmap() {
        roadmapContainer.innerHTML = '';
        phaseElements = [];

        roadmapData.forEach((phase, phaseIndex) => {
            const phaseHTML = createPhaseHTML(phase, phaseIndex);
            roadmapContainer.innerHTML += phaseHTML;
        });

        phaseElements = Array.from(roadmapContainer.querySelectorAll('.phase'));

        // No event listeners for checkboxes as they are disabled.
        // Progress is solely based on roadmapData.

        // Initial progress calculation based on roadmapData
        roadmapData.forEach((phase, phaseIndex) => {
            phase.sprints.forEach((sprint, sprintIndex) => {
                updateSprintProgress(phaseIndex, sprintIndex);
            });
        });
        updateOverallProgressAndMilestones();

        currentPhaseIndex = 0; // Always start at phase 0

        if (phaseElements.length > 0) {
            showPhase(currentPhaseIndex);
        } else {
            prevPhaseBtn.disabled = true;
            nextPhaseBtn.disabled = true;
        }
    }

    function updateSprintProgress(phaseIndex, sprintIndex) {
        const sprintId = `p${phaseIndex}-s${sprintIndex}`;
        const sprintElement = document.getElementById(`sprint-${sprintId}`);
        if (!sprintElement) return;

        const sprintData = roadmapData[phaseIndex].sprints[sprintIndex];
        const implTotal = sprintData.implementations.length;
        const implDone = sprintData.implementations.filter(item => item.done).length;
        const testsTotal = sprintData.keyTests.length;
        const testsPassed = sprintData.keyTests.filter(item => item.passed).length;

        const totalCheckboxes = implTotal + testsTotal;
        const checkedCount = implDone + testsPassed;

        const progress = totalCheckboxes > 0 ? (checkedCount / totalCheckboxes) * 100 : 0;

        const progressBar = document.getElementById(`progress-${sprintId}`);
        if (progressBar) {
            progressBar.style.width = `${progress.toFixed(0)}%`;
        }
    }

    function updateOverallProgressAndMilestones() {
        let totalTasks = 0;
        let completedTasks = 0;
        let cumulativeTasks = 0;
        milestoneMarkersContainer.innerHTML = '';
        milestoneLegendContainer.innerHTML = '';

        roadmapData.forEach(phase => {
            phase.sprints.forEach(sprint => {
                totalTasks += sprint.implementations.length + sprint.keyTests.length;
                completedTasks += sprint.implementations.filter(item => item.done).length;
                completedTasks += sprint.keyTests.filter(item => item.passed).length;
            });
        });

        if (totalTasks === 0) {
            overallProgressBar.style.width = `0%`;
            overallProgressBar.textContent = `0%`;
            return;
        }

        const overallProgressPercentage = (completedTasks / totalTasks) * 100;
        overallProgressBar.style.width = `${overallProgressPercentage.toFixed(0)}%`;
        overallProgressBar.textContent = `${overallProgressPercentage.toFixed(0)}%`;

        roadmapData.forEach((phase, index) => {
            let tasksInPhase = 0;
            phase.sprints.forEach(sprint => {
                tasksInPhase += sprint.implementations.length + sprint.keyTests.length;
            });
            cumulativeTasks += tasksInPhase;
            const markerPosition = (cumulativeTasks / totalTasks) * 100;

            if (markerPosition < 100) {
                const marker = document.createElement('div');
                marker.classList.add('milestone-marker');
                marker.style.left = `${markerPosition}%`;
                marker.style.backgroundColor = phaseColors[index % phaseColors.length];
                marker.title = `End of ${phase.phaseTitle}`; // Add tooltip
                milestoneMarkersContainer.appendChild(marker);
            }

            const legendItem = document.createElement('div');
            legendItem.classList.add('legend-item');
            const colorBox = document.createElement('div');
            colorBox.classList.add('legend-color-box');
            colorBox.style.backgroundColor = phaseColors[index % phaseColors.length];
            legendItem.appendChild(colorBox);
            const legendText = document.createElement('span');
            legendText.textContent = `${phase.phaseTitle}`; // Shorter legend text
            legendItem.appendChild(legendText);
            milestoneLegendContainer.appendChild(legendItem);
        });
    }


    function showPhase(index) {
        if (phaseElements.length === 0) {
            prevPhaseBtn.disabled = true;
            nextPhaseBtn.disabled = true;
            return;
        }
        phaseElements.forEach((phaseEl, i) => {
            if (i === index) {
                phaseEl.style.display = 'block';
                setTimeout(() => phaseEl.classList.add('active'), 10);
            } else {
                phaseEl.classList.remove('active');
                setTimeout(() => { if (!phaseEl.classList.contains('active')) phaseEl.style.display = 'none'; }, 500);
            }
        });
        prevPhaseBtn.disabled = index === 0;
        nextPhaseBtn.disabled = index === phaseElements.length - 1;
        // No longer saving currentPhaseIndex to localStorage
        if (roadmapContainer.offsetTop) {
            const headerOffset = 80;
            const elementPosition = roadmapContainer.getBoundingClientRect().top + window.pageYOffset;
            const offsetPosition = elementPosition - headerOffset;
            window.scrollTo({ top: offsetPosition, behavior: 'smooth' });
        }
    }

    prevPhaseBtn.addEventListener('click', () => {
        if (currentPhaseIndex > 0) {
            currentPhaseIndex--;
            showPhase(currentPhaseIndex);
        }
    });

    nextPhaseBtn.addEventListener('click', () => {
        if (currentPhaseIndex < phaseElements.length - 1) {
            currentPhaseIndex++;
            showPhase(currentPhaseIndex);
        }
    });

    // Initial Load
    renderRoadmap();

</script>
</body>
</html>
